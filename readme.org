#+OPTIONS: toc:nil
#+TITLE: SFQ Library
#+AUTHOR: Kangbo
* sfqQubt
  Tools for SFQ research.
** Installation
   The code is developed in =python2=, but =python3= should not be a problem.
   #+BEGIN_SRC sh
   pip install sfqlib
   #+END_SRC
** A Qubit
  When a qubit is created, 
  each qubit has simply the 6 cardinal states, namely.
  [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [1.0, 1.0, 0.0], [1.0, 1.0j, 0.0], [1.0, -1.0, 0.0], [1.0, -1.0j, 0.0],
  Then we can evolve the qubit by evolving all 6 states.
*** Qubit types
    + Sfq3LevelQubit: A qubit that includes the leakage level.
    + Sfq2LevelQubit: An ideal two level qubit.
    + Sfq3LevelEulerQubit: Three level qubit with euler angles recorded.
    + Sfq2LevelEulerQubit: Two level qubit with euler angles recorded.
*** Create a qubit
    A qubit is defined by 
    + Qubit frequency (both w_{01} and w_{12})
    + Clock frequency.
    + Rotation induced by a single SFQ pulse.
    + Target rotation, against which we define the infidelity.
    For example, to create a 3 level qubit.
    #+BEGIN_SRC python
    qubit = Sfq3LevelQubit(d_theta=pi/200, w_clock=2*pi*5e9,
          w_qubit=(2*pi*5.0e9, 2*pi*9.8e9), theta=pi/2)
    #+END_SRC
** Qubit Evolution.
*** Evolve a qubit
    We can do three basic things on a qubit.
    Suppose that we created a qubit
    #+BEGIN_SRC python
    qubit = Sfq3LevelQubit(d_theta=pi/200, w_clock=2*pi*5e9,
          w_qubit=(2*pi*5.0e9, 2*pi*9.8e9), theta=pi/2)
    #+END_SRC
**** Precess
     We can precess the qubit for one clock period.
     (multiplying all 6 states by the free precession time evolution operator).
     #+BEGIN_SRC python
     qubit.precess()
     #+END_SRC
**** SFQ Pulse and Precess
     We can apply a pulse and then precess.
     It is =pulse_and_precess= rather than =pulse= because
       + Applying two pulses consecutively is not possible experimentally.
       + It simplifies programming.
     #+BEGIN_SRC python
     qubit.pulse_and_precess()
     #+END_SRC
**** Measure the fidelity
     The fidelity is averaged over the 6 states.
     #+BEGIN_SRC python
     qubit.measure_fidelity()
     #+END_SRC
     In case of three level qubits, you can optionally ignore the indelity due to leakage level.
     #+BEGIN_SRC python
     qubit.measure_fidelity(ignore_leakage=True)
     #+END_SRC
**** More operations
*** More usage
     You can apply arbitrary pulse sequences by interleaving 
     =precess= and =pulse_and_precess=, 
     but there are a few helper functions for doing that.
**** Resonance
      You can apply a resonance requence that achieves that target rotation by
      #+BEGIN_SRC 
      qubit.resonance()
      #+END_SRC
**** Pulse pattern
     A sequence can be specified as a bit string.
     Each bit corresponds to a clock edge, 
     where 1 means applying a SFQ pulse,
     and 0 means not applying a SFQ pulse at the clock edge.
     For example, if you want to apply pulse at the 4th and 6th clock cycle.
     #+BEGIN_SRC 
     pattern = [0, 0, 0, 1, 0, 1]
     qubit.pulse_pattern(pattern)
     #+END_SRC
*** Pulse sequence
**** Create a pattern
     To avoid the tedium of typing up patterns,
     we can specify a pattern as a decimal number.
     a class =sfqsequence= is provided for this purpose.
     for example, one can create the bit pattern [1, 0, 0, 0] like the following.
     #+BEGIN_SRC python
     sequence = sfqsequence(8, 4).binary
     #+END_SRC
     this is convinent for enumerating sequences. 
     #+BEGIN_SRC python
     [sfqsequence(i, 10) for i in range(pow(2, 10))]
     #+END_SRC
**** Evolve the qubit
     To apply a sequence to a qubit.
     #+BEGIN_SRC python
   qubit.pulse_pattern(pattern, sequence.binary):
     #+END_SRC
     As another example, to try all possible sequences of n bits long.
     #+BEGIN_SRC python
      def search_sequences_of_length(self, n):
          def try_sequence(sequence_num):
              qubit = self.Sfq3LevelQubit(
                  d_theta=self.d_theta_n/n, w_clock=self.w_clock,
                  w_qubit=(2*pi*5.0e9, 2*pi*9.8e9), theta=pi/2)
              sequence = SfqSequence(sequence_num, n)
              qubit.pulse_pattern(sequence.binary)
              sequence.fidelity = qubit.measure_fidelity()
              return sequence
          all_seq_of_length_n = [try_sequence(sequence_num)
                                for sequence_num in range(pow(2, n))]
          return all_seq_of_length_n
     #+END_SRC
